#!/usr/bin/env ruby
# frozen_string_literal: true

require "pathname"
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../../Gemfile",
                                           Pathname.new(__FILE__).realpath)

require "rubygems"
require "bundler/setup"

require "optparse"
require "csv"
require "sanscript"

options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: csv2nex [options] file.csv"
  opts.on("-t", "--transpose", "Transpose CSV") do
    options[:transpose] = true
  end
end
optparse.parse!

abort(optparse.banner) if ARGV.empty?

infile = File.expand_path(ARGV.shift.to_s)
unless File.exist?(infile)
  STDERR.puts "File #{infile} not found."
  STDERR.puts optparse
  exit(1)
end

csv = CSV.read(infile, "r:bom|utf-8")
csv = csv.transpose if options[:transpose]
taxa_count = csv.first.count
character_count = csv.count - 1
taxa_labels = csv.first.map { |c| c.to_s.strip.scrub.gsub(/[^A-Za-z0-9]/, "_") }

@alphabet = ("A".."Z").to_a + ("a".."z").to_a

def weighted_uniq(array)
  weighted_hash = array.each_with_object({}) do |v, acc|
    acc[v] ||= 0
    acc[v] += 1
  end
  n = 0
  (weighted_hash.sort_by do |x|
    n += 1
    [-x[1], n]
  end).to_h
end

def sanitize_char(str)
  Sanscript.transliterate(str.to_s, :iast, :kh).gsub(/\s/, "_").tr("'", "`").strip
end

def tokenize(characters)
  char_set = weighted_uniq(characters.map { |c| sanitize_char(c) }.reject(&:empty?))
  char_set.each_with_object({}).with_index do |(char, acc), i|
    acc[char[0]] = [@alphabet[i], char[1]]
  end
end

character_labels = []
character_matrix = taxa_labels.map { |t| [t] }
(1..character_count).each do |r|
  row = csv[r]
  token_hash = tokenize(row)
  character_label = (token_hash.map do |k, _|
    "'#{sanitize_char(k)}'"
  end).join(" ")
  character_labels << %(#{r} /#{character_label})
  row.each_with_index do |charstate, i|
    token = token_hash[sanitize_char(charstate)]
    character_matrix[i] << (token.nil? ? "-" : token[0])
  end
end
character_matrix.map! do |arr|
  "#{arr.shift} #{arr.join('')}"
end

nexus_output = <<~NEXUS_EOF
  #NEXUS

  BEGIN TAXA;
  	TITLE Manuscripts;
  	DIMENSIONS NTAX=#{taxa_count};
  	TAXLABELS #{taxa_labels.join(' ')};
  END;

  BEGIN CHARACTERS;
  	TITLE  Variant_Matrix;
  	DIMENSIONS  NCHAR=#{character_count};
  	FORMAT DATATYPE = STANDARD RESPECTCASE GAP = - MISSING = ? SYMBOLS = "#{@alphabet.join(' ')}";
  	CHARSTATELABELS #{character_labels.join(', ')};
  	MATRIX
  		#{character_matrix.join("\n\t\t")}
  ;

  END;

  BEGIN ASSUMPTIONS;
  OPTIONS DEFTYPE = UNORD;
  END;

  BEGIN PAUP;
  Log File=paup.log Replace=Yes;
  Set Monitor=no;
  Set Criterion=parsimony;
  Set Root=midpoint;
  Set SemiGraph=yes;
  Set StoreBrLens=yes;
  Set Autoclose=yes;
  PSet Opt=MINF;
  PSet StepMatrix=ObsOnly;
  PSet GapMode=missing;
  HSearch AddSeq=Random ReconLimit=Infinity;
  SortTrees;
  RootTrees rootMethod=midpoint;
  PSet Opt=ACCTran;
  ConTree / strict=no majrule=yes rootMethod=midpoint saveSupport=both treefile=con.tree replace=yes;
  DescribeTrees ALL / plot=phylogram rootMethod=midpoint brLens=yes labelNode=yes
                  chgList=yes taxLabels=full showTaxNum=yes;
  Factory;
  END;

NEXUS_EOF

puts nexus_output
